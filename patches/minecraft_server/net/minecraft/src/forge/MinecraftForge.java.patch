--- ../src_base/minecraft_server/net/minecraft/src/forge/MinecraftForge.java	0000-00-00 00:00:00.000000000 -0000
+++ ../src/minecraft_server/net/minecraft/src/forge/MinecraftForge.java	0000-00-00 00:00:00.000000000 -0000
@@ -97,7 +97,7 @@
     {
         ForgeHooks.connectionHandlers.add(handler);
     }
-    
+
     /**
      * Registers a new Chunk Load event handler
      * @param handler The Handler to be registered
@@ -133,7 +133,7 @@
     {
         ForgeHooks.chatHandlers.add(handler);
     }
-    
+
     /**
      * Register a new Save handler
      * @param handler The handler to be registered
@@ -186,6 +186,7 @@
         for (String key : oreDict.keySet())
         {
             List<ItemStack> ores = oreDict.get(key);
+
             for (ItemStack stack : ores)
             {
                 handler.registerOre(key, stack);
@@ -200,12 +201,15 @@
     public static void registerOre(String oreClass, ItemStack ore)
     {
         List<ItemStack> orelist = oreDict.get(oreClass);
+
         if (orelist == null)
         {
             orelist = new ArrayList<ItemStack>();
             oreDict.put(oreClass, orelist);
         }
+
         orelist.add(ore);
+
         for (IOreHandler ioh : oreHandlers)
         {
             ioh.registerOre(oreClass, ore);
@@ -238,11 +242,13 @@
                     if (proto[i] instanceof Collection)
                     {
                         Iterator it = ((Collection)proto[i]).iterator();
+
                         if (!it.hasNext())
                         {
                             output = null;
                             break;
                         }
+
                         itering.addLast(it);
                         output.addLast(it.next());
                     }
@@ -262,8 +268,8 @@
             public Object[] next()
             {
                 Object[] tr = output.toArray();
-
                 Object to;
+
                 while (true)
                 {
                     if (itering.size() == 0)
@@ -271,29 +277,36 @@
                         output = null;
                         return tr;
                     }
+
                     to = itering.getLast();
                     output.removeLast();
+
                     if (to instanceof Iterator)
                     {
                         Iterator it = (Iterator)to;
+
                         if (it.hasNext())
                         {
                             output.addLast(it.next());
                             break;
                         }
                     }
+
                     itering.removeLast();
                 }
+
                 for (int i = itering.size(); i < proto.length; i++)
                 {
                     if (proto[i] instanceof Collection)
                     {
                         Iterator it = ((Collection)proto[i]).iterator();
+
                         if (!it.hasNext())
                         {
                             output = null;
                             break;
                         }
+
                         itering.addLast(it);
                         output.addLast(it.next());
                     }
@@ -303,6 +316,7 @@
                         output.addLast(proto[i]);
                     }
                 }
+
                 return tr;
             }
 
@@ -419,6 +433,7 @@
     public static void setBlockHarvestLevel(Block block, String toolClass, int harvestLevel)
     {
         ForgeHooks.initTools();
+
         for (int metadata = 0; metadata < 16; metadata++)
         {
             List key = Arrays.asList(block.blockID, metadata, toolClass);
@@ -426,7 +441,7 @@
             ForgeHooks.toolEffectiveness.add(key);
         }
     }
-    
+
     /** Returns the block harvest level for a particular tool class.
      *
      * @param block The block to check.
@@ -440,10 +455,12 @@
         ForgeHooks.initTools();
         List key = Arrays.asList(block.blockID, metadata, toolClass);
         Integer harvestLevel = (Integer)ForgeHooks.toolHarvestLevels.get(key);
-        if(harvestLevel == null)
+
+        if (harvestLevel == null)
         {
             return -1;
         }
+
         return harvestLevel;
     }
 
@@ -459,6 +476,7 @@
     public static void removeBlockEffectiveness(Block block, String toolClass)
     {
         ForgeHooks.initTools();
+
         for (int metadata = 0; metadata < 16; metadata++)
         {
             List key = Arrays.asList(block.blockID, metadata, toolClass);
@@ -604,6 +622,7 @@
                 return mob.getValue1();
             }
         }
+
         return 0;
     }
 
@@ -615,18 +634,21 @@
     public static String getRandomDungeonMob(Random rand)
     {
         float maxRarity = 0f;
+
         for (ObjectPair<Float, String> mob : dungeonMobs)
         {
             maxRarity += mob.getValue1();
         }
 
         float targetRarity = rand.nextFloat() * maxRarity;
+
         for (ObjectPair<Float, String> mob : dungeonMobs)
         {
             if (targetRarity < mob.getValue1())
             {
                 return mob.getValue2();
             }
+
             targetRarity -= mob.getValue1();
         }
 
@@ -702,6 +724,7 @@
     {
         float rarity = 0;
         ArrayList<ObjectPair<Float, DungeonLoot>> lootTmp = (ArrayList<ObjectPair<Float, DungeonLoot>>)dungeonLoot.clone();
+
         if (minCount < 0)
         {
             for (ObjectPair<Float, DungeonLoot> loot : lootTmp)
@@ -736,18 +759,21 @@
     public static ItemStack getRandomDungeonLoot(Random rand)
     {
         float maxRarity = 0f;
+
         for (ObjectPair<Float, DungeonLoot> loot : dungeonLoot)
         {
             maxRarity += loot.getValue1();
         }
 
         float targetRarity = rand.nextFloat() * maxRarity;
+
         for (ObjectPair<Float, DungeonLoot> loot : dungeonLoot)
         {
             if (targetRarity < loot.getValue1())
             {
                 return loot.getValue2().generateStack(rand);
             }
+
             targetRarity -= loot.getValue1();
         }
 
@@ -756,7 +782,7 @@
 
     //Achievement Pages ----------------------------------------
     private static LinkedList<AchievementPage> achievementPages = new LinkedList<AchievementPage>();
-    
+
     /**
      * Registers an achievement page.
      * @param page The page.
@@ -767,9 +793,10 @@
         {
             throw new RuntimeException("Duplicate achievement page name \"" + page.getName() + "\"!");
         }
+
         achievementPages.add(page);
     }
-    
+
     /**
      * Will return an achievement page by its index on the list.
      * @param index The page's index.
@@ -779,7 +806,7 @@
     {
         return achievementPages.get(index);
     }
-    
+
     /**
      * Will return an achievement page by its name.
      * @param name The page's name.
@@ -794,9 +821,10 @@
                 return page;
             }
         }
+
         return null;
     }
-    
+
     /**
      * Will return the list of achievement pages.
      * @return the list's size
@@ -805,7 +833,7 @@
     {
         return new HashSet<AchievementPage>(achievementPages);
     }
-    
+
     /**
      * Will return whether an achievement is in any page or not.
      * @param achievement The achievement.
@@ -814,11 +842,12 @@
     {
         for (AchievementPage page : achievementPages)
         {
-            if (page.getAchievements().contains(achievement)) 
+            if (page.getAchievements().contains(achievement))
             {
                 return true;
             }
         }
+
         return false;
     }
 
@@ -832,7 +861,7 @@
      * @param cart The minecart.
      * @param item The item used to place the cart.
      */
-    public static void registerMinecart(Class<? extends EntityMinecart> cart, ItemStack item)
+    public static void registerMinecart(Class <? extends EntityMinecart > cart, ItemStack item)
     {
         registerMinecart(cart, 0, item);
     }
@@ -845,7 +874,7 @@
      * @param type The minecart type, used to differentiate carts that have the same class.
      * @param item The item used to place the cart.
      */
-    public static void registerMinecart(Class<? extends EntityMinecart> minecart, int type, ItemStack item)
+    public static void registerMinecart(Class <? extends EntityMinecart > minecart, int type, ItemStack item)
     {
         MinecartKey key = new MinecartKey(minecart, type);
         itemForMinecart.put(key, item);
@@ -857,10 +886,11 @@
      * @param minecart
      * @param type
      */
-    public static void removeMinecart(Class<? extends EntityMinecart> minecart, int type)
+    public static void removeMinecart(Class <? extends EntityMinecart > minecart, int type)
     {
         MinecartKey key = new MinecartKey(minecart, type);
         ItemStack item = itemForMinecart.remove(key);
+
         if (item != null)
         {
             minecartForItem.remove(item);
@@ -875,7 +905,7 @@
      * @param minecart The cart class
      * @return An ItemStack that can be used to place the cart.
      */
-    public static ItemStack getItemForCart(Class<? extends EntityMinecart> minecart)
+    public static ItemStack getItemForCart(Class <? extends EntityMinecart > minecart)
     {
         return getItemForCart(minecart, 0);
     }
@@ -889,13 +919,15 @@
      * @param type The minecartType value
      * @return An ItemStack that can be used to place the cart.
      */
-    public static ItemStack getItemForCart(Class<? extends EntityMinecart> minecart, int type)
+    public static ItemStack getItemForCart(Class <? extends EntityMinecart > minecart, int type)
     {
         ItemStack item = itemForMinecart.get(new MinecartKey(minecart, type));
+
         if (item == null)
         {
             return null;
         }
+
         return item.copy();
     }
 
@@ -918,9 +950,10 @@
      * @param item The item to test.
      * @return Cart if mapping exists, null if not.
      */
-    public static Class<? extends EntityMinecart> getCartClassForItem(ItemStack item)
+    public static Class <? extends EntityMinecart > getCartClassForItem(ItemStack item)
     {
         MinecartKey key = null;
+
         for (ItemStack tmpKey : minecartForItem.keySet())
         {
             if (tmpKey.isItemEqual(item))
@@ -929,10 +962,12 @@
                 break;
             }
         }
+
         if (key != null)
         {
             return key.minecart;
         }
+
         return null;
     }
 
@@ -946,6 +981,7 @@
     public static int getCartTypeForItem(ItemStack item)
     {
         MinecartKey key = null;
+
         for (ItemStack tmpKey : minecartForItem.keySet())
         {
             if (tmpKey.isItemEqual(item))
@@ -954,10 +990,12 @@
                 break;
             }
         }
+
         if (key != null)
         {
             return key.type;
         }
+
         return -1;
     }
 
@@ -968,10 +1006,12 @@
     public static Set<ItemStack> getAllCartItems()
     {
         Set<ItemStack> ret = new HashSet<ItemStack>();
+
         for (ItemStack item : minecartForItem.keySet())
         {
             ret.add(item.copy());
         }
+
         return ret;
     }
 
@@ -993,6 +1033,7 @@
         {
             return false;
         }
+
         ForgeHooks.entityTrackerMap.put(entityClass, new EntityTrackerInfo(mod, ID, range, updateFrequency, sendVelocityInfo));
         return true;
     }
@@ -1016,6 +1057,7 @@
                 }
             }
         }
+
         return null;
     }
 
@@ -1031,11 +1073,13 @@
         for (Map.Entry<Class, EntityTrackerInfo> entry : ForgeHooks.entityTrackerMap.entrySet())
         {
             EntityTrackerInfo info = entry.getValue();
+
             if (type == info.ID && modID == getModID(info.Mod))
             {
                 return entry.getKey();
             }
         }
+
         return null;
     }
 
@@ -1065,6 +1109,7 @@
                 return entry.getKey();
             }
         }
+
         return -1;
     }
 
@@ -1075,6 +1120,7 @@
     public static NetworkMod[] getNetworkMods()
     {
         ArrayList<NetworkMod> ret = new ArrayList<NetworkMod>();
+
         for (BaseMod mod : (List<BaseMod>)ModLoader.getLoadedMods())
         {
             if (mod instanceof NetworkMod)
@@ -1082,6 +1128,7 @@
                 ret.add((NetworkMod)mod);
             }
         }
+
         return ret.toArray(new NetworkMod[0]);
     }
 
@@ -1124,10 +1171,10 @@
     {
         ForgeHooks.arrowLooseHandlers.add(handler);
     }
-    
+
     /**
      * Sends a packet on the specified NetworkManager
-     * 
+     *
      * @param net The manager to send the packet on
      * @param packet The packet to be sent
      */
@@ -1135,40 +1182,40 @@
     {
         ForgeHooks.getPacketHandler().sendPacket(net, packet);
     }
-    
+
     /**
      * Sends a 'small' payload packet to the specified manager.
      * It uses the Packet131MapData packet for it's communication
      * so things are limited.
-     * 
+     *
      * @param net The manager to send the packet to
      * @param mod The mod associated with this packet
      * @param id The ID number used to identify this packet
      * @param data The data to be sent, must be no larger then 255 bytes.
      */
     public static void sendPacket(NetworkManager net, NetworkMod mod, short id, byte[] data)
-    {   
+    {
         if (data == null)
         {
             data = new byte[0];
         }
-        
+
         if (data.length > 255)
         {
             throw new IllegalArgumentException(String.format("Data argument was to long, must not be longer then 255 bytes was %d", data.length));
         }
-        
+
         Packet131MapData pkt = new Packet131MapData();
         pkt.itemID   = (short)getModID(mod);
         pkt.uniqueID = id;
         pkt.itemData = data;
         sendPacket(net, pkt);
     }
-    
+
     /**
      * Helper function for wrapping and sending a Packet132TileEntityData packet,
      * useful so we don't have to edit the packet class itself to add the constructor on the client side.
-     * 
+     *
      * @param net The manager to send the packet to
      * @param x Position X
      * @param y Position Y
@@ -1190,44 +1237,43 @@
         pkt.customParam3 = par3;
         sendPacket(net, pkt);
     }
-    
+
     private static int isClient = -1;
     public static boolean isClient()
     {
         if (isClient == -1)
         {
-            try 
+            try
             {
                 Class.forName("net.minecraft.client.Minecraft", false, MinecraftForge.class.getClassLoader());
                 isClient = 1;
-            } 
-            catch (ClassNotFoundException e) 
+            }
+            catch (ClassNotFoundException e)
             {
                 isClient = 0;
-            }   
+            }
         }
+
         return isClient == 1;
     }
-    
+
     static
     {
         addDungeonMob("Skeleton", 1.0f);
         addDungeonMob("Zombie",   2.0f);
         addDungeonMob("Spider",   1.0f);
-
-        addDungeonLoot(new ItemStack(Item.saddle),          1.00f      );
+        addDungeonLoot(new ItemStack(Item.saddle),          1.00f);
         addDungeonLoot(new ItemStack(Item.ingotIron),       1.00f, 1, 4);
-        addDungeonLoot(new ItemStack(Item.bread),           1.00f      );
+        addDungeonLoot(new ItemStack(Item.bread),           1.00f);
         addDungeonLoot(new ItemStack(Item.wheat),           1.00f, 1, 4);
         addDungeonLoot(new ItemStack(Item.gunpowder),       1.00f, 1, 4);
         addDungeonLoot(new ItemStack(Item.silk),            1.00f, 1, 4);
-        addDungeonLoot(new ItemStack(Item.bucketEmpty),     1.00f      );
-        addDungeonLoot(new ItemStack(Item.appleGold),       0.01f      );
+        addDungeonLoot(new ItemStack(Item.bucketEmpty),     1.00f);
+        addDungeonLoot(new ItemStack(Item.appleGold),       0.01f);
         addDungeonLoot(new ItemStack(Item.redstone),        0.50f, 1, 4);
-        addDungeonLoot(new ItemStack(Item.record13),        0.05f      );
-        addDungeonLoot(new ItemStack(Item.recordCat),       0.05f      );
-        addDungeonLoot(new ItemStack(Item.dyePowder, 1, 3), 1.00f      );
-
+        addDungeonLoot(new ItemStack(Item.record13),        0.05f);
+        addDungeonLoot(new ItemStack(Item.recordCat),       0.05f);
+        addDungeonLoot(new ItemStack(Item.dyePowder, 1, 3), 1.00f);
         registerMinecart(EntityMinecart.class, 0, new ItemStack(Item.minecartEmpty));
         registerMinecart(EntityMinecart.class, 1, new ItemStack(Item.minecartCrate));
         registerMinecart(EntityMinecart.class, 2, new ItemStack(Item.minecartPowered));
