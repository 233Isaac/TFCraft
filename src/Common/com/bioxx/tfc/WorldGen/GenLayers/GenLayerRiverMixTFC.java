package com.bioxx.tfc.WorldGen.GenLayers;

import net.minecraft.world.gen.layer.GenLayer;
import net.minecraft.world.gen.layer.IntCache;

import com.bioxx.tfc.Core.TFC_Core;
import com.bioxx.tfc.WorldGen.TFCBiome;

public class GenLayerRiverMixTFC extends GenLayerTFC
{
	private GenLayer biomePatternGeneratorChain;
	private GenLayer riverPatternGeneratorChain;

	public GenLayerRiverMixTFC(long par1, GenLayer par3GenLayer, GenLayer par4GenLayer)
	{
		super(par1);
		this.biomePatternGeneratorChain = par3GenLayer;
		this.riverPatternGeneratorChain = par4GenLayer;
	}

	/**
	 * Returns a list of integer values generated by this layer. These may be interpreted as temperatures, rainfall
	 * amounts, or biomeList[] indices based on the particular GenLayer subclass.
	 */
	@Override
	public int[] getInts(int x, int z, int xSize, int zSize)
	{
		int[] layerBiomes = this.biomePatternGeneratorChain.getInts(x, z, xSize, zSize);
		int[] layerRivers = this.riverPatternGeneratorChain.getInts(x, z, xSize, zSize);
		int[] layerOut = IntCache.getIntCache(xSize * zSize);

		for (int index = 0; index < xSize * zSize; ++index)
		{
			int b = layerBiomes[index];
			int r = layerRivers[index];

			int xn = index-1;
			int xp = index+1;
			int zn = index-zSize;
			int zp = index+zSize;

			if (TFC_Core.isOceanicBiome(b) || TFC_Core.isMountainBiome(b))
				layerOut[index] = b;
			else if (layerRivers[index] > 0)
			{
				layerOut[index] = r;

				if (TFC_Core.isBeachBiome(b))
				{
					layerOut[index] = TFCBiome.ocean.biomeID;
					if(xn >= 0 && layerOut[xn] == TFCBiome.river.biomeID)
					{
						layerOut[xn] = TFCBiome.ocean.biomeID;
					}
					if(zn >= 0 && layerOut[zn] == TFCBiome.river.biomeID)
					{
						layerOut[zn] = TFCBiome.ocean.biomeID;
					}
					if(zp < layerBiomes.length && TFC_Core.isOceanicBiome(layerBiomes[zp]) && layerRivers[zn] == 0)
					{
						layerOut[index] = b;
					}
					if(zn >= 0 && TFC_Core.isOceanicBiome(layerBiomes[zn]) && layerRivers[zp] == 0)
					{
						layerOut[index] = b;
					}
					if(xn >= 0 && TFC_Core.isOceanicBiome(layerBiomes[xn]) && layerRivers[xp] == 0)
					{
						layerOut[index] = b;
					}
					if(xp < layerBiomes.length && TFC_Core.isOceanicBiome(layerBiomes[xp]) && layerRivers[xn] == 0)
					{
						layerOut[index] = b;
					}
				}
			}
			else
				layerOut[index] = b;

			if(layerOut[index] == TFCBiome.river.biomeID)
			{
				if(xn >= 0 && layerBiomes[xn] == TFCBiome.lake.biomeID)
				{
					layerOut[index] = TFCBiome.lake.biomeID;
				}
				if(zn >= 0 && layerBiomes[zn] == TFCBiome.lake.biomeID)
				{
					layerOut[index] = TFCBiome.lake.biomeID;
				}
				if(xp < layerBiomes.length && layerBiomes[xp] == TFCBiome.lake.biomeID)
				{
					layerOut[index] = TFCBiome.lake.biomeID;
				}
				if(zp < layerBiomes.length && layerBiomes[zp] == TFCBiome.lake.biomeID)
				{
					layerOut[index] = TFCBiome.lake.biomeID;
				}
			}
		}
		return layerOut;
	}

	/**
	 * Initialize layer's local worldGenSeed based on its own baseSeed and the world's global seed (passed in as an
	 * argument).
	 */
	@Override
	public void initWorldGenSeed(long par1)
	{
		this.biomePatternGeneratorChain.initWorldGenSeed(par1);
		this.riverPatternGeneratorChain.initWorldGenSeed(par1);
		super.initWorldGenSeed(par1);
	}
}
